Objects name themselves: it's one of \koDi's main selling points.

The names are generated by a precedure: \ldots

Overwriting behaviour.

\begin{tcblisting}{kodi snippet}
\SmashAndCenter{\begin{kodi}
\obj{ |[overwrite=false] (A')| A &     % names: A'    (default)
      |[overwrite=alias] (B')| B &     % names: B', B
      |[overwrite=true ] (C')| C \\ }; % names:     C
\mor A' -> B';
\mor B  -> C;
\end{kodi}}
\end{tcblisting}

Expansion behaviour.

\begin{tcblisting}{kodi snippet}
\SmashAndCenter{\begin{kodi}
\def\B{Z} \def\A{\B}
\obj{ |[expand=none]| \A &     % name: A (default)
      |[expand=once]| \A &     % name: B
      |[expand=full]| \A \\ }; % name: Z
\mor A -> B -> Z;
\end{kodi}}
\end{tcblisting}


% \begin{tcblisting}{kodi snippet}
% \SmashAndCenter{\begin{kodi}
% \obj{ |[replace=_ with u]| A_C &
%       |[replace=B with Y]| ABC \\ };
% \mor AuC -> AYC;
% \end{kodi}}
% \end{tcblisting}





\hrulefill\null




\begin{tcblisting}{kodi snippet}
\SmashAndCenter{\begin{kodi}
  \foreach [count=\r] \l in {A,B,C}
    \foreach [count=\c] \n in {n-1,n,n+1}
      \obj [expand=full] at (3em*\c,-3em*\r) {\l_{\n}};
  \mor (C_{n+1}) -> (B_{n-1});
  \mor (B_{n+1}) -> (A_{n-1});
\end{kodi}}
\end{tcblisting}

\begin{tcblisting}{kodi snippet}
\SmashAndCenter{\begin{kodi}
  \obj{
    A & B & C \\
  };
  \mor B -> C;
\end{kodi}}
\end{tcblisting}
