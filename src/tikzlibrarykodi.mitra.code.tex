%===[ What is this? ]===========================================================

% μήτρα • (mítra)
%  1. womb
%  2. matrix
%  3. mold

% This module implements an alternative parsing mechanism
% for TiKz matrices of nodes.

\tikzset{
  mitra/.style={
    matrix,
    cells={anchor=base},
    execute at begin cell=\kDBeginCell,
    execute at empty cell=\kDEmptyCell,
  },
  %: MEMO: this *cannot* be put along with global node styles (because order of execution)
  matrix coordinates alias/.style={
    alias=\tikzmatrixname-\the\pgfmatrixcurrentrow-\the\pgfmatrixcurrentcolumn,
  },
}










\bgroup
\def\:{\global\let\kDBlankSpace= }\:
\egroup

\long\def\kDIfNextChar#1#2#3{%
\let\kDINCToken= #1% <- MEMO: this space is crucial
\def\kDINCTrue{#2}\def\kDINCFalse{#3}%
\futurelet\kDINCTok\kDINC%
}

\def\kDINC%
  {\ifx\kDINCTok\kDINCToken\let\kDINCFalse\kDINCTrue\fi\kDINCFalse}

\def\kDIdentity#1{#1}

\catcode`@=11

\newif\ifkDRTSHasTrail
\newif\ifkDRTSPrevSpace

\def\kDRTSGob{%
\kDIfNextChar\kD%
{\ifkDRTSPrevSpace\kDRTSHasTrailtrue\else\kDRTSHasTrailfalse\fi\pgfutil@gobble}%
{\kDIfNextChar\kDBlankSpace%
{\kDRTSPrevSpacetrue\expandafter\kDRTSGob\kDIdentity}%
{\kDRTSPrevSpacefalse\expandafter\kDRTSGob\pgfutil@gobble}%
}%
}

\def\kDRemoveTrailingSpace#1{
\kDRTSPrevSpacefalse
\edef\kDRTSAct{\noexpand\kDRTSGob\the#1\noexpand\kD}\kDRTSAct
\ifkDRTSHasTrail
\def\kDRTSCut##1 \kD{#1={##1}}
\edef\kDRTSAct{\noexpand\kDRTSCut\the#1\noexpand\kD}\kDRTSAct
\fi
}

\catcode`@=12















\newtoks\kDTokOpt
\newtoks\kDTokBuf

\newtoks\buf

\catcode`@=11

\newif\ifConTeXt
% Trick stolen from iftex. The second line is expanded inside the group so
% the global scope isn't polluted by \csname defining the token.
\begingroup\expandafter\expandafter\expandafter\endgroup\expandafter
  \ifx\csname starttext\endcsname\relax\ConTeXtfalse\else\ConTeXttrue\fi


\newif\ifkDCurrentRowReady
\kDCurrentRowReadyfalse

\def\kDBeginCell{%
\ifConTeXt\catcode`|=12 \fi% TODO: why is the space necessary?
\ifkDCurrentRowReady%
\expandafter\kDParseCell\else%
\expandafter\kDPrepareCurrentRow\fi%
}

\bgroup
\catcode`&=\active

\gdef\kDPrepareCurrentRow#1\\{%
\global\kDCurrentRowReadytrue%
\buf={#1&\\}\edef\tmp{\the\buf}%\show\tmp%
\expandafter\kDBeginCell\tmp%
}

\gdef\kDFetchContent#1&%
{\kDTokBuf={#1}\kDRemoveTrailingSpace\kDTokBuf\kDMakeCell}

\gdef\kDMakeCell{%
\kDMakeNode%
\ifkDMitraDebug\kDMitraDebugDump\fi%
\pgfutil@ifnextchar\\{\global\kDCurrentRowReadyfalse}%
{\pgfutil@ifnextchar&{&{}}{&}}% fill up incoming empty cells with {}
}

\egroup

\def\kDParseCell%
{\pgfutil@ifnextchar|{\kDFetchOptions}{\kDFetchOptions||}}

% TODO: is an identity really the smartest way to remove leading whitespace?
\def\kDFetchOptions|#1|%
{\kDTokOpt={#1}\expandafter\kDFetchContent\kDIdentity}

\def\kDMakeNode{%
\edef\kDBuiltNode{\noexpand\node\the\kDTokOpt[
  node contents={\the\kDTokBuf},
  matrix coordinates alias
];}%
\kDBuiltNode%
}

\def\kDEmptyCell{%
\kDTokOpt={}%
\kDTokBuf={}%
\kDMakeNode%
\ifkDMitraDebug\kDMitraDebugDump\fi%
}

\newif\ifkDMitraDebug
\kDMitraDebugfalse

\def\kDMitraDebugDump{
  \pgfextra{
    \bgroup\let~\space
    \immediate\write\file{'\the\pgfmatrixcurrentrow-\the\pgfmatrixcurrentcolumn':}
    \immediate\write\file{~~options: '\the\kDTokOpt'}
    \immediate\write\file{~~content: '\the\kDTokBuf'}
    \egroup
  }
}

\catcode`@=12



