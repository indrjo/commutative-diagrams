% ράμμα • (rámma)
%   1. suture
%   2. catgut
%   3. stitch

% Ramma ties together the lower level libraries to define
% the user level functionality. NOTE: strictly no aesthetics, see mandyas.

\usetikzlibrary[kodi.bapto]
\usetikzlibrary[kodi.ektropi]
\usetikzlibrary[kodi.katharizo]
\usetikzlibrary[kodi.koinos]
\usetikzlibrary[kodi.ozos]
\usetikzlibrary[kodi.mitra]
\usetikzlibrary[kodi.velos]

% And here is the core idea of koDi itself:

\pgfqkeys{/tikz}{% TODO: is this the best scope to put the key into?
  self naming/.style={
    /tikz/node contents/.forward to=/katharizo/input,
    /katharizo/output/.forward to=/bapto/input
  }
}

% Some mischief with handlers and baseline math/labeling functionality.

\pgfqkeys{/kD}{
  .search also=/bapto,
  .search also=/katharizo,
  every thing/.style={
    /ektropi/restore,
    /ektropi/add=/kD,
    /ektropi/add=/bapto,
    /ektropi/add=/katharizo,
  },
  every diagram/.style={% NOTE: restore hopefully unnecessary
    /kD/every thing,
    /ektropi/add=/kD/diagrams,
  },
  every layout/.style={% NOTE: restore unnecessary
    /kD/every thing,
    /ektropi/add=/kD/layouts,
    nodes={/kD/every object}
  },
  every object/.style={% NOTE: needed when inside matrices
    /kD/every thing,
    /ektropi/add=/kD/objects,
    execute at begin node=$,%
    execute at end node=$,%
    self naming,
  },
  every arrow/.style={% NOTE: restore unnecessary
    /kD/every thing,
    /ektropi/add=/kD/arrows
  },
  every label/.style={% NOTE: restore needed because inside edge
    /kD/every thing,
    /ektropi/add=/kD/labels,
    execute at begin node=$,%
    execute at end node=$,%
    self naming
  }
}

% The user level keys are bound to the underlying parsers.

\pgfkeys{
  /mitra/every matrix/.append style=/kD/every layout,
  /ozos/every node/.append style=/kD/every object,
  /velos/every path/.append style={
    /tikz/every edge/.append style=/kD/every arrow,
    /tikz/every edge quotes/.append style=/kD/every label
  }
}

% I merge the macro syntax for objects and matrices. Convenient!

\newif\ifkDObjIsMatrix

\def\kDObjDecideWhetherIsMatrixThen#1{%
  \def\kDObjDWIM{\kDObjDWIMSightThen{\kDObjDWIMGobThen{#1}}}%
  \expandafter\kDObjDWIM\the\kDGrpTok\\\kD}

\def\kDObjDWIMSightThen#1#2\\%
  {\kDIfNextHardCh\kD
    {\kDObjIsMatrixfalse#1}%
    {\kDObjIsMatrixtrue#1}}

\def\kDObjDWIMGobThen#1#2\kD{#1}

\def\kDObjOutput
  {\ifkDObjIsMatrix
    \kDMitraParseMatrixTableThen\kDMitraOutput\else
    \kDOzosOutput\fi}

\def\kDObj
  {\kDFetchOptAndGrpThen
  {\kDObjDecideWhetherIsMatrixThen
   \kDObjOutput}}

% I envelope the koDi main macros in a simple key for maximal flexibility.

\tikzset{
  kodi/.code={%
    \catcode`\|=12% ConTeXt hack TODO: is it sufficient? investigate
    \let\obj\kDObj
    \let\mor\kDVelos
  },
  kodi/.append style={/kD/every diagram}
}

% TODO: not convinced by the structure of what follows

%==[ main macro ]===============================================================

\def\kDRamma
  {\kDRammaMaybeFetchOptionsThen
   \kDRammaOutput}

%==[ fetching routine ]=========================================================

\newtoks\kDRammaOptTok
\newtoks\kDRammaTmpTok

\def\kDRammaMaybeFetchOptionsThen#1{%
  \kDRammaOptTok={}%
  \kDIfNextHardCh[%
    {\kDRammaFetchOptionsThen{#1}}%
    {#1}}

\def\kDRammaFetchOptionsThen#1[#2]{\kDRammaOptTok={#2}#1}

%==[ output routine ]===========================================================

\def\kDRammaOutput{%
  \edef\kDAct{%
    \noexpand\kDRammaTmpTok={%
      \noexpand\tikzpicture[kodi, \the\kDRammaOptTok]}}%
  \kDAct
  \the\kDRammaTmpTok}

\let\kDkoDiOpen\kDRamma
\let\kDkoDiShut\endtikzpicture
