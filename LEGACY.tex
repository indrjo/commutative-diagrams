
    % fallback as parameter to given key after searching for key in /tikz
    % fallback to/.code 2 args={%
        % \let\searchname=\pgfkeyscurrentname%
        % \pgfkeysalso{
            % /tikz/\searchname/.try=#1,
            % #2/.retry/.expand once=\searchname,
        % }%
    % },
    % keys to hold kD styles sorted by kind
    % objects/.unknown/.style={
        % /kD/fallback to={#1}{/kD/math node contents},
    % },
    % arrows/.search also=/tikz,
    % labels/.unknown/.style={
        % /kD/fallback to={#1}{/kD/math node contents},
    % },



\pgfqkeys{/handlers}{
    first char syntax=true,
    first char syntax/.cd,
        % the character (/.initial=\kDNamingShortcut,
        the character "/.initial=\kDContentShortcut,
}

% \def\kDPeelRoundParentheses(#1){#1}

% \def\kDNamingShortcut#1{%
    % \pgfkeysalso{
        % /tikz/name/.expand once={\kDPeelRoundParentheses#1},
    % }%
% }

\def\kDPeelDoubleQuotes"#1"{#1}

\def\kDContentShortcut#1{%
    \pgfkeysalso{
        /kD/math node contents/.expand once={\kDPeelDoubleQuotes#1},
    }%
}






% ==================================================================== PARSING =

%% OBSOLETE

% \pgfqkeys{/kD/parse}{
  % bisect/.code args={#1at#2into#3and#4}{%
    % \def\Cut#2##1#2##2#2##3\GO%
      % {\def\cnt{##3}\def\one{#2}\def\two{#2#2}%
       % \ifx\cnt\one\kDCSDef{#3}{##1}\kDCSDef{#4}{}\else%
       % \ifx\cnt\two\kDCSDef{#3}{##2}\kDCSDef{#4}{##1}\else%
       % \errmessage{A bisection crashed.}\fi\fi}%
    % \Cut#2#1#2#2#2\GO%
  % },
  % /tikz/edge node string/.code args={[#1]#2}{%
    % \ifx\relax#1\relax\else\tikzset{edge node={node[/kD/parse/label={#1},/kD/render/label]}}\fi%
    % \ifx\relax#2\relax\else\tikzset{edge node string={#2}}\fi%
  % },
  % arrow/.forward to=/kD/current arrow/.style,
  % label/.forward to=/kD/current label/.style,
  % morphism/.style={
    % /kD/parse/bisect={#1}at{:}into{kDSND}and{kDFST},
    % /kD/parse/arrow/.expand once=\kDSND,
    % /kD/parse/labels/.expand once=\kDFST,
  % },
  % chain/.style={
    % /kD/parse/bisect={#1}at{:}into{kDSND}and{kDFST},
    % /kD/current chain/every arrow/.estyle=\kDSND,
    % /kD/current chain/every label/.estyle=\kDFST,
  % },
  % labels/.code={%
    % \ifx\relax#1\relax\else%
    % \def\doit##1##2\GO{\def\tmp{##1}}\def\sqr{[}\doit#1\GO%
    % \ifx\tmp\sqr%
      % \pgfkeysalso{/kD/current arrow/.append style={edge node string={#1}}}\else%
      % \pgfkeysalso{/kD/current arrow/.append style={edge node string={[#1]}}}\fi%
    % \fi%
  % },
% }

% ================================================================== RENDERING =

% OBSOLETE

% \pgfqkeys{/kD/render}{
  % morphism/.style={
    % /kD/arrows/.cd,
    % /kD/every arrow,
    % /kD/current chain/every arrow,
    % /kD/current arrow,
  % },
  % label/.style={
    % /kD/labels/.cd,
    % /kD/every label,
    % /kD/current chain/every label,
    % /kD/current label,
  % },
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\def\kDChopParse#1|#2|#3\GO%
%  {\kDBalancerInit\pgfdecoratedpathlength
%   \kDBalancerTally#1\to One\GO
%   \kDBalancerTally#2\to Two\GO
%   \kDBalancerTally#3\to Thr\GO
%   \expandafter\kDBalancerGauge\One\to Fst\GO
%   \expandafter\kDBalancerGauge\Thr\to Lst\GO
%   \pgfmathsetmacro\start{\Fst}
%   \pgfmathsetmacro\stop{1-\Lst}}
%
%\tikzset{/kD/arrows/chop/.style={
%  decoration={
%    show path construction,
%    curveto code={
%      \kDFullExpandAfter\kDChopParse{#1}\GO
%      \pgfpathcurvebetweentime{\start}{\stop}
%      {\pgfpointdecoratedinputsegmentfirst}
%      {\pgfpointdecoratedinputsegmentsupporta}
%      {\pgfpointdecoratedinputsegmentsupportb}
%      {\pgfpointdecoratedinputsegmentlast}},
%    lineto code={
%      \kDFullExpandAfter\kDChopParse{#1}\GO
%      \pgfpathcurvebetweentime{\start}{\stop}
%      {\pgfpointdecoratedinputsegmentfirst}
%      {\pgfpointdecoratedinputsegmentfirst}
%      {\pgfpointdecoratedinputsegmentlast}
%      {\pgfpointdecoratedinputsegmentlast}}
%  },decorate},
%  % the following key has to be integrated into the syntax of the main key
%  /kD/arrows/schop/.style={/kD/arrows/chop=#1|*|#1},}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ============================================================ INTERNAL MACROS =
% The TikZ code is used to define mid level macros.

% \def\kDDoMorphism#1 #2 #3\GO%
  % {\path (#1) edge [/kD/parse/morphism={#2}, /kD/render/morphism] (#3);}
% 
% \let\kDThisSource\relax \let\kDLastSource\relax
% \let\kDThisTarget\relax \let\kDLastTarget\relax
% \def\kDLast{*}
% 
% \def\kDDoMorphismChain#1 #2 #3 #4\GO%
  % {\def\kDSource{#1}\ifx\kDSource\kDLast\let\kDSource\kDLastSource\fi%
   % \def\kDTarget{#3}\ifx\kDTarget\kDLast\let\kDTarget\kDLastTarget\fi%
   % \kDDoMorphism{\kDSource} {#2} {\kDTarget}\GO%
   % \ifx\kDThisSource\relax\let\kDThisSource\kDSource\fi%
   % \ifx\relax#4\relax%
   % \let\kDLastSource\kDThisSource\let\kDThisSource\relax%
   % \let\kDLastTarget\kDTarget%
   % \else\kDDoMorphismChain{#3} #4\GO%
   % \fi}
% 
% \def\kDDoMorphismChainWithoutOptions #1;%
  % {\kDDoMorphismChainWithOptions[] #1;}
% 
% \def\kDDoMorphismChainWithOptions[#1] #2;%
  % {\pgfqkeys{/kD/parse}{chain={#1}}%
   % \kDDoMorphismChain#2 \GO}

%=====[ FRONT END ]=============================================================












% \def\kDCSDef#1#2%
  % {\expandafter\def\csname#1\endcsname{#2}}

% Define a macro and its starred version from a pair of macros
% so that #1*=#2 and #1=#3
% \def\kDDefStarred#1\with#2\and#3\GO%
  % {\kDCSDef{#1}%
    % {\expandafter\futurelet\expandafter\kDMaybeStar%
     % \csname#1MaybeStarred\endcsname}%
   % \kDCSDef{#1MaybeStarred}%
    % {\ifx*\kDMaybeStar\let\next#2\else\let\next#3\fi\next}}
% 
% \def\kDCSDefOptional#1\with#2\and#3\GO%
  % {\kDCSDef{#1}%
     % {\expandafter\futurelet\expandafter\kDFirstCharacter%
      % \csname kD#1MaybeOptions\endcsname}%
   % \kDCSDef{kD#1MaybeOptions}%
     % {\ifx[\kDFirstCharacter\let\kDTmp#2\else\let\kDTmp#3\fi\kDTmp}}

%\def\kDGobble#1\with#2\at#3\into#4\GO%
%  {\def\Gobbler##1#3##2\GO{#2##1\GO\ifx##2\relax\else\Gobbler##2\GO\fi}%
%   \kDCSDef{#4}{\Gobbler#1\GO}}

%\def\kDFullExpandAfter#1#2{\edef\tmp{#2}\expandafter#1\tmp}

% ============================================================ PARSING HELPERS =

%\def\kDSplice#1\at#2\into#3\and#4\GO%
%  {\def\Rimmer##1#2\GO{\kDCSDef{#4}{##1}}%
%   \def\Cutter##1#2##2\GO%
%     {\def\snd{##2}\ifx\snd\empty\kDCSDef{#3}{}\kDCSDef{#4}{##1}%
%      \else\kDCSDef{#3}{##1}\Rimmer##2\GO\fi}%
%   \Cutter#1#2\GO}

%\def\kDTrisect#1\at#2\into#3\and#4\and#5\GO%
%  {\def\Cut#2##1#2##2#2##3#2##4\GO%
%     {\def\cnt{##4}\def\one{#2}\def\two{#2#2}\def\thr{#2#2#2}
%      \ifx\cnt\one\kDCSDef{#3}{##1}\kDCSDef{#4}{}   \kDCSDef{#5}{}   \else
%      \ifx\cnt\two\kDCSDef{#3}{##2}\kDCSDef{#4}{##1}\kDCSDef{#5}{}   \else
%      \ifx\cnt\thr\kDCSDef{#3}{##3}\kDCSDef{#4}{##2}\kDCSDef{#5}{##1}\else
%      \errmessage{PROBLEMS, YO!}\fi\fi\fi}
%   \Cut#2#1#2#2#2#2\GO}

%\def\kDBisect#1\at#2\into#3\and#4\GO%
%  {\def\Cut#2##1#2##2#2##3\GO%
%     {\def\cnt{##3}\def\one{#2}\def\two{#2#2}
%      \ifx\cnt\one\kDCSDef{#3}{##1}\kDCSDef{#4}{}   \else
%      \ifx\cnt\two\kDCSDef{#3}{##2}\kDCSDef{#4}{##1}\else
%      \errmessage{PROBLEMS, YO!}\fi\fi}
%   \Cut#2#1#2#2#2\GO}













% There macros are the primitives to handle length partitioning.
% Rigid lengths are either a dimension or a number representing a fraction
% of the Total.  Loose lengths are starred numbers that proportionally fill
% the rest.  So, a specification like
%     0|0.1|*|*3|1cm    with Total=10cm
% would ultimately be parsed as
%     0cm|1cm|2cm|6cm|1cm
% These macros here parse just single numbers, but standard gobbling procedure
% can easily generalize the parsing to a string like the example.

%\def\kDChopParse#1|#2|#3\GO%
%  {\kDBalancerInit\pgfdecoratedpathlength
%   \kDBalancerTally#1\to One\GO
%   \kDBalancerTally#2\to Two\GO
%   \kDBalancerTally#3\to Thr\GO
%   \expandafter\kDBalancerGauge\One\to Fst\GO
%   \expandafter\kDBalancerGauge\Thr\to Lst\GO
%   \pgfmathsetmacro\start{\Fst}
%   \pgfmathsetmacro\stop{1-\Lst}}

%\pgfqkeys{/kD/balancer}{
%}

% Basic initialization
% \def\kDBalancerInit#1%
  % {\def\kDBalancerLoose{0}%
   % \def\kDBalancerRigid{0}%
   % \def\kDBalancerTotal{#1}}

% First we tally the totals
% \def\kDBalancerTallyLoose*#1\to#2\GO%
  % {\ifx\relax#1\relax\pgfmathparse{1}\else\pgfmathparse{#1}\fi%
   % \expandafter\edef\csname#2\endcsname{*\pgfmathresult}%
   % \pgfmathsetmacro\kDBalancerLoose{\kDBalancerLoose+\pgfmathresult}}
% \def\kDBalancerTallyRigid#1\to#2\GO%
  % {\ifx\relax#1\relax\pgfmathparse{0}\else\pgfmathparse{#1}\fi%
   % \ifpgfmathunitsdeclared\pgfmathdivide{#1}{\kDBalancerTotal}\fi%
   % \expandafter\pgfmathsetmacro\csname#2\endcsname{\pgfmathresult}%
   % \pgfmathsetlengthmacro\kDBalancerRigid{\kDBalancerRigid+\pgfmathresult}}
% \kDDefStarred kDBalancerTally%
  % \with\kDBalancerTallyLoose%
   % \and\kDBalancerTallyRigid\GO

% Then we can produce the actual lengths
% \def\kDBalancerGaugeLoose*#1\to#2\GO%
  % {\expandafter\pgfmathsetmacro\csname#2\endcsname%
     % {#1*(1-\kDBalancerRigid)/\kDBalancerLoose}}
% \def\kDBalancerGaugeRigid#1\to#2\GO%
  % {\expandafter\pgfmathsetmacro\csname#2\endcsname{#1}}
% \kDDefStarred kDBalancerGauge%
  % \with\kDBalancerGaugeLoose%
   % \and\kDBalancerGaugeRigid\GO
